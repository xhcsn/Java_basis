# Java并发
## 1、什么是进程和线程
进程是程序的一次执行过程，是系统运行程序的基本单位；线程和进程类似，但是线程是一个比线程更小的执行单位。一个进程在其执行过程中可以产生多个线程。同类的多个线程共享进程的堆与方法区资源，但是每个线程拥有自己的程序计数器，虚拟机栈以及本地方法栈。因此线程被称为轻量级进程。

## 2、线程与进程的关系、区别及优缺点
一个进程中可以有多个线程，多个线程共享进程的堆与方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。

线程是进程划分成的更小的运行单位，线程和进程的最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会互相影响。线程执行开销小，但是不利于资源的管理和维护；而进程正好相反。

## 3、程序计数器为什么是私有的
程序计数器主要有以下两个作用：
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制；
- 在多线程的情况下，程序计数器用于记录当前进程执行的位置，从而当线程被切换回来的时候就能够知道该线程上次运行到哪儿了。

注：如果执行native方法的话，程序计数器记录的是undefined地址，只有执行的是Java代码时程序计数器记录的才是下一条指令的地址。

因此程序计数器私有主要是为了线程切换后能够恢复到正确的执行位置。

## 4、虚拟机栈和本地方法栈为什么是私有的
- 虚拟机栈：每一个Java方法在执行的时候会同时创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。
- 本地方法栈类似于虚拟机栈，为本地方法服务。

因此，虚拟机栈和本地方法栈私有是为了保证线程中的局部变量不被别的线程访问到。

## 5、并发和并行的区别
- 并发：在同一时间段，多个任务都在执行（单位时间内不一定同时执行）；
- 并行：在同一个时间点，多个任务都在进行

## 6、为什么要使用多线程以及使用多线程可能带来什么问题
使用多线程是为了提高CPU的利用率；使用多线程会造成内存泄漏、死锁、线程不安全等问题。

## 7、线程的生命周期和状态
new、runnable、blocked、wating、time-waiting、terminated

线程创建之后将处于新建状态，调用start()方法后开始运行，线程这时候处于ready状态。可运行状态的线程获得了CPU时间片后就处于running状态。这两个状态笼统地称为runnable状态；当线程执行wait方法以后，线程进入了wating状态，执行wait(long millis)方法后，线程将会进入time-waiting状态。当现场调用同步方法的时候，无法获取到锁的情况下，线程将会进入到blocked状态。线程在执行完之后会进入terminated状态。

## 8、什么是上下文切换
多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

任务从保存到再加载的过程就是一次上下文切换。

## 9、死锁产生的四个必要条件以及如何预防和避免线程死锁
### 死锁产生的必要条件：
- 互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
- 占有且等待：一个进程可以占有资源并且进行等待其他进程释放资源
- 不可抢占：不可抢占其他线程拥有的资源
- 循环等待，进程之间需要的资源形成一个循环等待的资源。
#### 预防死锁：
- 一次性申请所有的资源
- 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源
- 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件

## 10、sleep()方法和wait()方法区别和共同点
- 两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁
- 两者都可以暂停线程的执行：wait通常用于线程间交互/通信，sleep通常用于暂停执行
- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。

## 11、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
new一个Thread，线程进入了新建状态。调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。但是，直接执行run()方法，会把run()方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

## 12、对synchronized关键字的理解
synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。






















