# Java并发
## 1、什么是进程和线程
进程是程序的一次执行过程，是系统运行程序的基本单位；线程和进程类似，但是线程是一个比线程更小的执行单位。一个进程在其执行过程中可以产生多个线程。同类的多个线程共享进程的堆与方法区资源，但是每个线程拥有自己的程序计数器，虚拟机栈以及本地方法栈。因此线程被称为轻量级进程。

## 2、线程与进程的关系、区别及优缺点
一个进程中可以有多个线程，多个线程共享进程的堆与方法区资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。

线程是进程划分成的更小的运行单位，线程和进程的最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会互相影响。线程执行开销小，但是不利于资源的管理和维护；而进程正好相反。

## 3、程序计数器为什么是私有的
程序计数器主要有以下两个作用：
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制；
- 在多线程的情况下，程序计数器用于记录当前进程执行的位置，从而当线程被切换回来的时候就能够知道该线程上次运行到哪儿了。

注：如果执行native方法的话，程序计数器记录的是undefined地址，只有执行的是Java代码时程序计数器记录的才是下一条指令的地址。

因此程序计数器私有主要是为了线程切换后能够恢复到正确的执行位置。

## 4、虚拟机栈和本地方法栈为什么是私有的
- 虚拟机栈：每一个Java方法在执行的时候会同时创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程。
- 本地方法栈类似于虚拟机栈，为本地方法服务。

因此，虚拟机栈和本地方法栈私有是为了保证线程中的局部变量不被别的线程访问到。

## 5、并发和并行的区别
- 并发：在同一时间段，多个任务都在执行（单位时间内不一定同时执行）；
- 并行：在同一个时间点，多个任务都在进行

## 6、为什么要使用多线程以及使用多线程可能带来什么问题
使用多线程是为了提高CPU的利用率；使用多线程会造成内存泄漏、死锁、线程不安全等问题。

## 7、线程的生命周期和状态
new、runnable、blocked、wating、time-waiting、terminated

线程创建之后将处于新建状态，调用start()方法后开始运行，线程这时候处于ready状态。可运行状态的线程获得了CPU时间片后就处于running状态。这两个状态笼统地称为runnable状态；当线程执行wait方法以后，线程进入了wating状态，执行wait(long millis)方法后，线程将会进入time-waiting状态。当现场调用同步方法的时候，无法获取到锁的情况下，线程将会进入到blocked状态。线程在执行完之后会进入terminated状态。

## 8、什么是上下文切换
多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

任务从保存到再加载的过程就是一次上下文切换。

## 9、死锁产生的四个必要条件以及如何预防和避免线程死锁
### 死锁产生的必要条件：
- 互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
- 占有且等待：一个进程可以占有资源并且进行等待其他进程释放资源
- 不可抢占：不可抢占其他线程拥有的资源
- 循环等待，进程之间需要的资源形成一个循环等待的资源。
#### 预防死锁：
- 一次性申请所有的资源
- 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源
- 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件

## 10、sleep()方法和wait()方法区别和共同点
- 两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁
- 两者都可以暂停线程的执行：wait通常用于线程间交互/通信，sleep通常用于暂停执行
- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。

## 11、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
new一个Thread，线程进入了新建状态。调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。但是，直接执行run()方法，会把run()方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

## 12、对synchronized关键字的理解
synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

## 13、synchronized关键字的三种使用方式
- 修饰实例方法：作用于当前对象实例加锁，进入同步代码块需要获得当前对象实例的锁
- 修饰静态方法：给当前类加锁，作用于类的所有对象实例，进入同步代码块前要获得当前class的锁
- 修饰代码块：指定加锁对象，对给定对象/类加锁，表示进入同步代码块前要获得给定对象的锁

## 14、手写单例模式
```java
public class Singleton{
    private volatile static Singleton uniqueInstance;
    private Singleton（）{

    }
    public static Singleton getUniqueInstance(){
        if(uniqueInstance == null){
            synchronized(Singleton.class){
                if(uniqueInstance == null){
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

## 15、synchronized关键字的底层原理
#### synchronized同步语句块的情况
```java
public class SynchronizedDemo{
    public void method(){
        synchronized(this){
            System.out.println("synchronize代码块");
        }
    }
}
```

synchronized同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令指向同步代码块的结束位置

当执行monitorenter时，线程视图获取锁也就是获取对象监视器的持有权

#### synchronized修饰方法的情况
```java
public class SynchronizedDemo2{
    public synchronized void method(){
        System.out.println("synchronized方法");
    }
}
```
synchronized修饰的方法并没有monitorenter指令和monitorexit指令，而是使用了ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法。

本质而言都是对对象监视器monitor的获取。

## 16、JDK1.6之后对synchronized关键字进行了哪些优化
优化后synchronized锁可以分为：无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，锁可以升级但是不可以降级

- 无锁：未进行加锁
- 偏向锁：针对一个进程而言，如果没有发生锁的竞争，当前对象的锁是偏向于当前进程的。
- 轻量级锁：当有两个线程竞争锁，当前锁就会进化成轻量级锁，但是此时资源的竞争不是很激烈，当A线程获取c对象，B线程获取不到c对象的锁就会进入自旋，不断尝试获取锁，因为竞争不激烈，所以在指定次数自旋内B线程就会获取轻量级锁，如果获取失败那么就会升级成重量级锁。
- 重量级锁状态：获取不到资源的线程会阻塞

## 17、synchronized和ReentrantLock的区别
- 两者都是可重入锁
- synchronized关键字依赖于JVM的实现，ReentrantLock依赖于API，即通过lock()、unlock()配合try/finally实现的
- ReentrantLock比起synchronized增加了高级功能：
  - 等待可中断，即正在等待的线程可以放弃等待转而处理其他事情
  - 可实现公平锁：ReentrantLock可以指定公平锁还是非公平锁，synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁
  - 可以实现选择性通知：synchronized关键字与wait和notify方法相结合可以实现等待和通知、ReentrantLock可以通过Condition，选择性通知注册在指定Condition的所有等待线程

## 18、并发编程的三个重要特性
- 原子性：一组逻辑上的操作要么全部执行要么全部不执行
- 可见性：当一个线程对共享变量进行了修改，其他的线程立即可以看到修改后的最新值
- 有序性：代码在执行的过程中禁止指令重排

## 19、ThreadLocal
如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，可以使用get和set方法来获取默认值或者将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。



































