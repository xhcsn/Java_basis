## 1、介绍一下Java内存区域
#### 程序计数器
程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

为了线程切换后能够恢复到正确的执行位置，每条线程都需要有独立的程序计数器，各个线程之间计数器互相不影响，独立存储，为线程私有的区域。

#### Java虚拟机栈
Java虚拟机栈也是线程私有的，Java方法的每次调用都对应着一个栈帧从入栈到出栈的过程，Java虚拟机栈由多个栈帧组成，栈帧中有：局部变量表、操作数栈、动态链接、方法出口等信息。

局部变量表主要存放了编译期可知的各种数据类型、对象引用。

#### 本地方法栈
类似于Java虚拟机栈

#### 堆
几乎所有的对象实例都在这里分配内存
堆内存通常被分成以下三个部分：新生代、老年代、永久代；新生代又可以分为Eden区、from survivor、to survivor

#### 方法区
运行时常量池依旧在方法区中、字符串常量池放到了堆中

## 2、对象的创建
- 类加载检查：当虚拟机遇到一条new指令，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载解析初始化，没有的话，先执行相应的类加载过程
- 分配内存：为新生对象分配内存，分配方式有指针碰撞和空闲列表两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
- 初始化零值：将分配到的内存空间全部初始化零值
- 设置对象头：虚拟机需要对对象进行设置。如对象的分代年龄、类的元数据信息、对象的哈希码、是否启用偏向锁等
- 执行init方法：根据程序员的意愿进行初始化。

## 3、在对象创建过程中内存分配并发问题如何解决
- CAS+失败重试：CAS是乐观锁的一种实现方式，所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就进行重试，知道成功为止
- TLAB：为每个线程预先在Eden区分配一个内存，给对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或者TLAB的内存已经用尽时，再采用上述的CAS进行内存分配。

## 4、对象的内存布局
对象在内存中的布局可以分为3块区域：对象头、实例数据和对齐填充

- 对象头：包括两部分信息，第一部分用于存储对象自身的运行时数据（GC分代年龄、哈希码、锁状态标志），另一部分是类型指针（指向类元数据的指针）
- 实例数据：存储对象真正的有效信息
- 对齐填充：起到占位作用，因为一个对象的大小为8字节的整数倍

## 5、对象的访问定位
- 使用句柄：Java堆中会划分出来一块内存作为句柄池、reference中存储的是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息
- 直接指针：如果使用直接指针访问，那么Java堆对象的布局中需要考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

## 6、String类和常量池
```java
String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；
String str2 = new String("abcd");//堆中创建一个新的对象
String str3 = new String("abcd");//堆中创建一个新的对象
System.out.println(str1==str2);//false
System.out.println(str2==str3);//false
```
- 第一种方式是在常量池中拿对象
- 第二种方式是在堆内存空间创建一个新的对象

只要使用new方法，便需要创建新的对象

String类的常量池两种使用方法：
- 直接使用双引号声明出来的String对象会放入常量池中
- 如果不是用双引号声明的String对象，可以使用String提供的intern方法，是一个native方法。其作用为：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用

字符串拼接
```java
String str1 = "str";
String str2 = "ing";

String str3 = "str" + "ing";//常量池中的对象
String str4 = str1 + str2; //在堆上创建的新的对象
String str5 = "string";//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```

## 7、String s1 = new String("abc");这句话创建了几个字符串对象
将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。

## 8、8种基本数据类型的包装类
Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。 

Integer举例
```java
Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);

System.out.println("i1=i2   " + (i1 == i2));//True
System.out.println("i1=i2+i3   " + (i1 == i2 + i3));//True
System.out.println("i1=i4   " + (i1 == i4));//False
System.out.println("i4=i5   " + (i4 == i5));//False
System.out.println("i4=i5+i6   " + (i4 == i5 + i6));//True
System.out.println("40=i5+i6   " + (40 == i5 + i6));//True
```