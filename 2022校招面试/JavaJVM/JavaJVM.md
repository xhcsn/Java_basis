## 1、介绍一下Java内存区域
#### 程序计数器
程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

为了线程切换后能够恢复到正确的执行位置，每条线程都需要有独立的程序计数器，各个线程之间计数器互相不影响，独立存储，为线程私有的区域。

#### Java虚拟机栈
Java虚拟机栈也是线程私有的，Java方法的每次调用都对应着一个栈帧从入栈到出栈的过程，Java虚拟机栈由多个栈帧组成，栈帧中有：局部变量表、操作数栈、动态链接、方法出口等信息。

局部变量表主要存放了编译期可知的各种数据类型、对象引用。

#### 本地方法栈
类似于Java虚拟机栈

#### 堆
几乎所有的对象实例都在这里分配内存
堆内存通常被分成以下三个部分：新生代、老年代、永久代；新生代又可以分为Eden区、from survivor、to survivor

#### 方法区
运行时常量池依旧在方法区中、字符串常量池放到了堆中

## 2、对象的创建
- 类加载检查：当虚拟机遇到一条new指令，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载解析初始化，没有的话，先执行相应的类加载过程
- 分配内存：为新生对象分配内存，分配方式有指针碰撞和空闲列表两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
- 初始化零值：将分配到的内存空间全部初始化零值
- 设置对象头：虚拟机需要对对象进行设置。如对象的分代年龄、类的元数据信息、对象的哈希码、是否启用偏向锁等
- 执行init方法：根据程序员的意愿进行初始化。

## 3、在对象创建过程中内存分配并发问题如何解决
- CAS+失败重试：CAS是乐观锁的一种实现方式，所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就进行重试，知道成功为止
- TLAB：为每个线程预先在Eden区分配一个内存，给对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或者TLAB的内存已经用尽时，再采用上述的CAS进行内存分配。

## 4、对象的内存布局
对象在内存中的布局可以分为3块区域：对象头、实例数据和对齐填充

- 对象头：包括两部分信息，第一部分用于存储对象自身的运行时数据（GC分代年龄、哈希码、锁状态标志），另一部分是类型指针（指向类元数据的指针）
- 实例数据：存储对象真正的有效信息
- 对齐填充：起到占位作用，因为一个对象的大小为8字节的整数倍

## 5、对象的访问定位
- 使用句柄：Java堆中会划分出来一块内存作为句柄池、reference中存储的是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息
- 直接指针：如果使用直接指针访问，那么Java堆对象的布局中需要考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

## 6、String类和常量池
```java
String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；
String str2 = new String("abcd");//堆中创建一个新的对象
String str3 = new String("abcd");//堆中创建一个新的对象
System.out.println(str1==str2);//false
System.out.println(str2==str3);//false
```
- 第一种方式是在常量池中拿对象
- 第二种方式是在堆内存空间创建一个新的对象

只要使用new方法，便需要创建新的对象

String类的常量池两种使用方法：
- 直接使用双引号声明出来的String对象会放入常量池中
- 如果不是用双引号声明的String对象，可以使用String提供的intern方法，是一个native方法。其作用为：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用

字符串拼接
```java
String str1 = "str";
String str2 = "ing";

String str3 = "str" + "ing";//常量池中的对象
String str4 = str1 + str2; //在堆上创建的新的对象
String str5 = "string";//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```

## 7、String s1 = new String("abc");这句话创建了几个字符串对象
将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。

## 8、8种基本数据类型的包装类
Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。 

Integer举例
```java
Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);
System.out.println("i1=i2   " + (i1 == i2));//True
System.out.println("i1=i2+i3   " + (i1 == i2 + i3));//True
System.out.println("i1=i4   " + (i1 == i4));//False
System.out.println("i4=i5   " + (i4 == i5));//False
System.out.println("i4=i5+i6   " + (i4 == i5 + i6));//True
System.out.println("40=i5+i6   " + (40 == i5 + i6));//True
```

## 9、 JVM的分配担保机制
在新生代准备进行minorGC，首先检查老年代最大连续空间区域的大小是否大于新生代所有对象的大小；如果老年代能够装下所有新生代对象，minorGC没有风险，进行minorGC；如果老年代无法装下，垃圾收集器根据过去存活对象的平均数来预测这次minorGC后存活的对象的平均数。以往平均数小于当前老年代最大的连续空间就进行minorGC，大于则进行一次majorGC，给新生代做担保

## 10、动态对象年龄判定
Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的50%时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值

## 11、可达性分析算法
通过一系列的GC Roots的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的。

可以作为GC Roots的对象如下：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 本地方法栈（Native方法）中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

## 12、四种引用
- 强引用：使用的大部分引用都是强引用，当内存空间不足，虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，将其回收
- 软引用：可有可无的生活用品，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足，就会将其回收，用来实现一些缓存
- 弱引用：如果一个对象只具有弱引用，GC发现它就会将其回收掉
- 虚引用：形同虚设，虚引用并不会决定对象的生命周期，在任何时候都可能被垃圾回收

## 13、不可达的对象是否一定会被回收掉
要将一个对象回收，需要经过两次标记过程：可达性分析中不可达的对象被第一次标记并进行判断是否需要进行筛选，筛选的条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就真的会被回收。

## 14、如何判断一个常量是废弃常量
在字符串常量池中如果没有任何String对象引用该常量的话，该常量就是废弃常量

## 15、如何判断一个类是无用的类
- 该类的所有实例已经被回收
- 该类的类加载器已经被回收
- 无法从任何地方通过反射访问该类的方法

## 16、垃圾收集算法
#### 标记-清除算法
首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象
#### 标记-复制算法
将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样每次的内存回收就是对内存区间的一半进行回收。
#### 标记-整理算法
将所有存活的对象向一端移动，直接清理掉端边界以外的内存。
#### 分代收集算法
在新生代中，每次收集都会有大量的对象死去，因此可以选用标记-复制算法；对于老年代需要选取标记-清除，或者标记整理算法

## 17、垃圾收集器
#### Serial收集器
Serial收集器是最基本的垃圾收集器。它在进行垃圾收集的时候会暂停其他所有的工作线程，直到它收集结束
#### ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为和Serial收集器完全一样
#### Parallel Scavenge收集器
类似于ParNew收集器，也是多线程版本的收集器。但是其更加关注吞吐量（即CPU的利用率）
#### CMS收集器
CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它非常注重用户的体验

其垃圾收集过程分为四个步骤：
- 初始标记：暂停所有的其他线程，并且记录直接与root相连的对象，速度很快。
- 并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象
- 重新标记：修正并发标记中因为用户程序继续运行而导致标记产生变动的记录
- 并发清楚：用户线程和GC线程并发执行，GC线程对垃圾进行回收

缺点：
- 对 CPU 资源敏感；
- 无法处理浮动垃圾；
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
#### G1收集器
G1是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。





















