## 1、介绍一下Java内存区域
#### 程序计数器
程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

为了线程切换后能够恢复到正确的执行位置，每条线程都需要有独立的程序计数器，各个线程之间计数器互相不影响，独立存储，为线程私有的区域。

#### Java虚拟机栈
Java虚拟机栈也是线程私有的，Java方法的每次调用都对应着一个栈帧从入栈到出栈的过程，Java虚拟机栈由多个栈帧组成，栈帧中有：局部变量表、操作数栈、动态链接、方法出口等信息。

局部变量表主要存放了编译期可知的各种数据类型、对象引用。

#### 本地方法栈
类似于Java虚拟机栈

#### 堆
几乎所有的对象实例都在这里分配内存
堆内存通常被分成以下三个部分：新生代、老年代、永久代；新生代又可以分为Eden区、from survivor、to survivor

#### 方法区
运行时常量池依旧在方法区中、字符串常量池放到了堆中

## 2、对象的创建
- 类加载检查：当虚拟机遇到一条new指令，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载解析初始化，没有的话，先执行相应的类加载过程
- 分配内存：为新生对象分配内存，分配方式有指针碰撞和空闲列表两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
- 初始化零值：将分配到的内存空间全部初始化零值
- 设置对象头：虚拟机需要对对象进行设置。如对象的分代年龄、类的元数据信息、对象的哈希码、是否启用偏向锁等
- 执行init方法：根据程序员的意愿进行初始化。

## 3、在对象创建过程中内存分配并发问题如何解决
- CAS+失败重试：CAS是乐观锁的一种实现方式，所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就进行重试，知道成功为止
- TLAB：为每个线程预先在Eden区分配一个内存，给对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或者TLAB的内存已经用尽时，再采用上述的CAS进行内存分配。

## 4、对象的内存布局
对象在内存中的布局可以分为3块区域：对象头、实例数据和对齐填充

- 对象头：包括两部分信息，第一部分用于存储对象自身的运行时数据（GC分代年龄、哈希码、锁状态标志），另一部分是类型指针（指向类元数据的指针）
- 实例数据：存储对象真正的有效信息
- 对齐填充：起到占位作用，因为一个对象的大小为8字节的整数倍

## 5、对象的访问定位
- 使用句柄：Java堆中会划分出来一块内存作为句柄池、reference中存储的是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息
- 直接指针：如果使用直接指针访问，那么Java堆对象的布局中需要考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

## 6、String类和常量池
```java
String str1 = "abcd";//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；
String str2 = new String("abcd");//堆中创建一个新的对象
String str3 = new String("abcd");//堆中创建一个新的对象
System.out.println(str1==str2);//false
System.out.println(str2==str3);//false
```
- 第一种方式是在常量池中拿对象
- 第二种方式是在堆内存空间创建一个新的对象

只要使用new方法，便需要创建新的对象

String类的常量池两种使用方法：
- 直接使用双引号声明出来的String对象会放入常量池中
- 如果不是用双引号声明的String对象，可以使用String提供的intern方法，是一个native方法。其作用为：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用

字符串拼接
```java
String str1 = "str";
String str2 = "ing";

String str3 = "str" + "ing";//常量池中的对象
String str4 = str1 + str2; //在堆上创建的新的对象
String str5 = "string";//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```

## 7、String s1 = new String("abc");这句话创建了几个字符串对象
将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。

## 8、8种基本数据类型的包装类
Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。 

Integer举例
```java
Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);
System.out.println("i1=i2   " + (i1 == i2));//True
System.out.println("i1=i2+i3   " + (i1 == i2 + i3));//True
System.out.println("i1=i4   " + (i1 == i4));//False
System.out.println("i4=i5   " + (i4 == i5));//False
System.out.println("i4=i5+i6   " + (i4 == i5 + i6));//True
System.out.println("40=i5+i6   " + (40 == i5 + i6));//True
```

## 9、 JVM的分配担保机制
在新生代准备进行minorGC，首先检查老年代最大连续空间区域的大小是否大于新生代所有对象的大小；如果老年代能够装下所有新生代对象，minorGC没有风险，进行minorGC；如果老年代无法装下，垃圾收集器根据过去存活对象的平均数来预测这次minorGC后存活的对象的平均数。以往平均数小于当前老年代最大的连续空间就进行minorGC，大于则进行一次majorGC，给新生代做担保

## 10、动态对象年龄判定
Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的50%时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值

## 11、可达性分析算法
通过一系列的GC Roots的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的。

可以作为GC Roots的对象如下：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 本地方法栈（Native方法）中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

## 12、四种引用
- 强引用：使用的大部分引用都是强引用，当内存空间不足，虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，将其回收
- 软引用：可有可无的生活用品，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足，就会将其回收，用来实现一些缓存
- 弱引用：如果一个对象只具有弱引用，GC发现它就会将其回收掉
- 虚引用：形同虚设，虚引用并不会决定对象的生命周期，在任何时候都可能被垃圾回收

## 13、不可达的对象是否一定会被回收掉
要将一个对象回收，需要经过两次标记过程：可达性分析中不可达的对象被第一次标记并进行判断是否需要进行筛选，筛选的条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就真的会被回收。

## 14、如何判断一个常量是废弃常量
在字符串常量池中如果没有任何String对象引用该常量的话，该常量就是废弃常量

## 15、如何判断一个类是无用的类
- 该类的所有实例已经被回收
- 该类的类加载器已经被回收
- 无法从任何地方通过反射访问该类的方法

## 16、垃圾收集算法
#### 标记-清除算法
首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象
#### 标记-复制算法
将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样每次的内存回收就是对内存区间的一半进行回收。
#### 标记-整理算法
将所有存活的对象向一端移动，直接清理掉端边界以外的内存。
#### 分代收集算法
在新生代中，每次收集都会有大量的对象死去，因此可以选用标记-复制算法；对于老年代需要选取标记-清除，或者标记整理算法

## 17、垃圾收集器
#### Serial收集器
Serial收集器是最基本的垃圾收集器。它在进行垃圾收集的时候会暂停其他所有的工作线程，直到它收集结束
#### ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为和Serial收集器完全一样
#### Parallel Scavenge收集器
类似于ParNew收集器，也是多线程版本的收集器。但是其更加关注吞吐量（即CPU的利用率）
#### CMS收集器
CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它非常注重用户的体验

其垃圾收集过程分为四个步骤：
- 初始标记：暂停所有的其他线程，并且记录直接与root相连的对象，速度很快。
- 并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象
- 重新标记：修正并发标记中因为用户程序继续运行而导致标记产生变动的记录
- 并发清除：用户线程和GC线程并发执行，GC线程对垃圾进行回收

缺点：
- 对 CPU 资源敏感；
- 无法处理浮动垃圾；
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
#### G1收集器
G1是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。

G1不需要每次将垃圾全部清理，而是清理具有更高优先级的垃圾。

G1将堆内存化整为零，将堆内存划分成了多个大小相等的独立区域，每个region都可以根据需要，扮演新生代的Eden空间、survivor空间或者老年代空间，收集器根据需要对不同角色的region采用不同的策略去处理。

G1的运行过程为如下四个步骤：
- 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象
- 并发标记：从GC Root开始对堆中对象进行可达性分析。
- 最终标记：对用户线程做一个短暂的暂停，用于处理并发标记阶段仍遗留下来的对象
- 筛选回收：根据用户所期望的停顿时间来制定回收计划
## 18、最常用的JVM参数配置
#### 堆内存相关
- 显示指定堆内存：-Xms和-Xmx
- 显示指定新生代内存：-XX:NewSize和-XX:MaxNewSize
- 显式指定永久代/元空间的大小：-XX:MetaspaceSize=N和-XX:MaxMetaspaceSize=N
#### 垃圾收集相关
- -XX:+UseSerialGC
- -XX:+UseParallelGC
- -XX:+USeParNewGC
- -XX:+UseG1GC

## 19、类加载器有哪些
- 启动类加载器（BootstrapClassLoader）：最顶层的加载类，负责加载%JAVA_HOME%/lib目录下的jar包和类或者或被-Xbootclasspath参数指定的路径中的所有类。
- 扩展类加载器（ExtensionClassLoader）：主要负责加载%JRE_HOME%/lib/ext目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。
- 应用程序类加载器（AppClassLoader）：面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。
- 用户自定义类加载器

## 20、双亲委派模型
每个类都有对应它的类加载器。系统中的ClassLoader在协同工作的时候会默认使用双亲委派模型，即在类加载的时候，系统会判断当前类是否被加载过。已经加载的类直接返回，否则先将所有的请求向上传递检查是否被加载，最终传到最顶层。再从上而下尝试加载

优点：双亲委派模型避免了类的重复加载，因为JVM区分不同类的方式不仅仅根据类名，相同的类文件经过不同的类加载器加载产生的是两个不同的类。

## 21、如何打破双亲委派模型
自定义类加载器的时候，需要继承ClassLoder。如果不想打破双亲委派模型，那么就重写ClassLoader类中的findClass方法，如果想要打破双亲委派模型，那么重写loadClass方法。

## 22、类加载的过程
#### 加载
- 通过全类名获取定义此类的二进制字节流
- 将二进制字节流所代表的的静态存储结构转换为方法区的运行时数据结构
- 在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口
#### 验证
- 文件格式验证：验证字节流是否符合Class文件的规范
- 元数据验证：对字节码描述的信息进行语义分析
- 字节码验证：确定程序语义是合法的
- 符号引用验证：确保解析动作能够正确执行
#### 准备
为类变量分配内存并且设置变量的初始值
#### 解析
将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。
#### 初始化
执行clinit方法，这一步JVM才开始真正执行类中定义的Java程序代码(字节码)。
#### 卸载
- 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。
- 该类没有在其他任何地方被引用
- 该类的类加载器的实例已被GC

## 23、Java类文件结构
#### 魔数
每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件。
#### Class文件版本号
第5位和第6位是次版本号，第7位和第8位是主版本号。
#### 常量池
常量池主要存放字面量和符号引用
#### 访问标志
在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息
#### 当前类、父类、接口索引集合
类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，接口索引集合用来描述这个类实现了那些接口。
#### 字段表集合
用于描述接口或类中声明的变量。
#### 方法表集合
methods_count 表示方法的数量，而 method_info 表示方法表。
#### 属性表集合
在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。








































